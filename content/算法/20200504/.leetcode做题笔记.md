---
createdAt: '2020-05-04'
updatedAt: '2020-05-04'
---
# 总结
+ 预处理：排序，原地hash
+ 数据结构：hash
+ 下标确定：二分法
+ 目标值/极值-下标/区间：积分法，指针夹逼
+ 动态规划（不保留过程，求极值）：临时变量、填表法
+ 回溯算法（保留过程）
+ 查找循环：快慢指针
+ 遍历回查：指针回查、bit回查、hash回查
+ 链表：自加节点，三节点
+ 出现次数最多：摩尔投票法
+ 链表翻转：pre、cur、next，从左往右翻转cur.next的方向

<!--more-->

* 积分法：数组与结果关系表现为无向性
  - max，sum，左右指针都在左边
  - 右指针扫描，计算sum，记录max
  - 确定拖累极值**状态**，一直重置左指针与sum
* 指针夹逼：数组与结果关系表现为有向性
  - max，sum，左右指针在左右
  - 计算sum，记录max，夹逼劣指针
* 摩尔投票法：查出数量最多的n个元素
  - 初始化n个坑位都为第一个元素，且其出现数量为0
  - 遍历数组，有对应坑位+1，否则全体-1
  - 如果有坑位要被减到负，则置换其一负坑位为当前值，出现数量为1
  - 最后坑位里的即出现次数最多的n个元素
* 排序矩阵搜索
  - 左上角/右下角：最小值/最大值
  - 左下角/右上角：能按照当前大小有方向行进
* 原地hash
  - 在原数组遍历，当前值与hash位置值交换，直到某条件调参交换，继续遍历hash交换

+ 先根遍历
```java
public static void 先根遍历(TreeNode root) {
    Stack<TreeNode> stack = new Stack<TreeNode>();
    while (root != null || !stack.isEmpty()) {
        while (root != null) {
            System.out.println(root.val);
            stack.add(root);
            root = root.left;
        }
        root = stack.pop();
        root = root.right;
    }
}
```
+ 中根遍历：二叉搜索树是升序遍历
```java
public void 中根遍历(TreeNode root) {
    Stack<TreeNode> stack = new Stack<>();
    while (root != null && !stack.isEmpty()) {
        while (root != null) {
            stack.add(root);
            root = root.left;
        }
        root = stack.pop();
        System.out.println(root.val);
        root = root.right;
    }
}
```
+ 后根遍历
```java
public void 后根遍历(TreeNode root) {
    if (root == null) {
        return;
    }
    后根遍历(root.left);
    后根遍历(root.right);
    System.out.println(root.val);
}
```
+ 层序遍历
```java
public void 层序遍历(Main.TreeNode root) {
    List<TreeNode> list = Arrays.asList(root);
    while (!list.isEmpty()) {
        List<TreeNode> ls = new LinkedList<>();
        for (TreeNode node : list) {
            System.out.println(node.val);
            if (node.left != null) {
                ls.add(node.left);
            }
            if (node.right != null) {
                ls.add(node.right);
            }
        }
        list = ls;
    }
}
```
+ 遍历树路径
```java
public void 遍历树路径(TreeNode root) {
    Stack<TreeNode> stack = new Stack<>();
    LinkedList<TreeNode> path = new LinkedList<>();
    while (root != null || !stack.isEmpty()) {
        while (root != null) {
            path.add(root);
            System.out.println(root.val + ": " + path);
            stack.add(root);
            root = root.left;
        }
        root = stack.pop();
        while (root != path.getLast()) {
            path.removeLast();
        }
        root = root.right;
    }
}
```

# 题目
+ ✔[1]两数之和：一般不会靠节省内存，多是考时间复杂度。想办法用上hashMap或者hashSet就能自动降低时间复杂度。

+ ✔[14]最长公共前缀：递归和二分法也能降低时间复杂度。递归适用于重复相同的操作，因此变成数组求和数组求公因数也是一样的。
  二分法感觉这里用的比较巧妙，对最短字符串进行二分。是不是确定下标位类型的都能用二分？

+ ✔[26]删除排序数组中的重复项：**指针回溯法**。我一开始想到的是用个二进制数字标记那些数字已经出现过，最后数一下出现过的数字的数量和值就好。

+ ✔[35]搜索插入位置：又是一个用二分法确定下标位的类型

+ ✔[53]最大子序和：**积分法**。这个有点有趣，可以把这个问题泛化为有一个函数f(x)，求区间`[a,b]`使得`∫(b,a)f(x)`最大，其中`a>A,b<B`。
  方法就是将x从左往右移动计算sum，记录出现过的max，但如果sum<0则将a重置为当前x，sum重置为0。使得尽可能将负的丢掉。
  例如`[-2,1,-3,4,-1,2,1,-5,4]`->`[-2|1 -2|4  3 5 6  1 5]`。其中`|`为重置的地方。

+ [69]x的平方根：计算平方根可以用二分法(好像高中?有介绍过,不过我忘了)，用于在一定可比较范围内求一值

+ ✔[70]爬楼梯：**动态规划，临时变量**。爬楼梯这个递归我想错地方了。连续的依赖性重复步骤，都可以类推为斐波那契数，也是动态规划，即第n步依赖于前几步的结果。
  根据实际问题，这个前几步的结果的求解可以用递归，也可以只用几个中间值临时保存。

+ [108]将有序数组转换为二叉搜索树：奇怪的题，取数组中间为根节点，左边的都是左节点，右边的都是右节点就满足要求了……？……。
  - 知识点：
  - 有序二叉树的中根遍历是有序的
  - 可以把`取数组中间为根节点，左边的都是左子树，右边的都是右子树`这个操作递归，能使得数平衡且最矮。

+ ✔[111]二叉树的最小深度：扫描有两种，一直深度扫，根据全局最小深度觉得要不要继续往下扫，以及更新全局最小深度。
  二是广度扫，扫到某一行有个叶子节点结束。

+ ✔[121]买卖股票的最佳时机：**积分法**。跟最大子序和类似。

+ [136]只出现一次的数字：本来我想的是用个二进制标记出现过的数组，出现第二次的时候把1设回0，最后是1的那个数字出现了一次。
  但是发现`^`这个位运算是自可逆的，即`n=n^a^a`，且`0^a=a`，所以搞个0跟全部的数`^`一下，最后就剩下只出现过一次的那个数字。

+ ✔[141]环形链表：**快慢指针**。有趣的题，用两个引用，第一个引用每次走一步，第二个引用走两步，如果循环，那这两个引用肯定会相等。快慢指针

+ ✔[160]相交链表：老题了，以前阿里面试面过。对齐两个链表的尾，长的先跑，跑到短的头，再一起向前。

+ [167]两数之和 II - 输入有序数组：**指针夹逼**。在两数之和I里是用map解决的，如果要空间O(1)，有序数组，我本来想到的是用二分法替代map。
  但如果用两个下标，放在数组头和数组尾，两数之和大了，大下标往左移，直到和等于目标值，结束。
  或者和小于目标值，小下标往右移一位，大下标在原地继续往左移，直到两下标相遇。

+ ✔[169]多数元素：一条奇妙的题
  - 解法一：最菜的hash表计数
  - 解法二：将数值排序，中间的那个数就是众数（依赖于众数有过半数）
  - 解法三：数值左边的众数与右边的众数的结果就是全局众数，进行递归（依赖于众数有过半数）
  - 解法四：假设第一个数为众数，遍历数值，遇到众数sum+1，非众数sum-1，sum==0时更换众数为当前数。总感觉与最大子序和、买卖股票类似。

+ ✔[172]阶乘后的零：多少个0有多少个10(2*5)，2数量>5数量，所以等于`n/5 + n/25 + n/125 ……`。
  但是`5->25->125`这样下去容易超过int，所以应该是将n/5替代`5->25->125`。

+ ✔[189]旋转数组：有点神奇
  - 将整个数组挪三次
  - 将数字一步到位放到对应位置，用两个下标和临时变量。麻烦的是如果`k%n==0`会下标循环。
    没能完全想明白在这种情况下，嵌多一层循环判断下标循环，之后开始的下标比上一次+1就好。
  - 将整个数组翻转，之后分别将数组`[:k-1]`和`[k:]`的内部再翻转，这个有点巧妙，展示没想到其他拓展

+ ✔[198]打家劫舍：**动态规划，临时变量**。全部的(暂时没想到反例)第k步的决策取决与前n(n有限)步的结果，则这种动态规划都可以通过设备n个临时变量+一次遍历+保存决策过程中的目标值解决。

+ ✔[202]快乐数：**快慢指针**。貌似全部的查找循环都可以用快慢指针？

+ ✔[204]计数质数：用了一个bool数组保存0-n的数是不是素数，默认全部都是，循环1的i从2(确实是素数)开始，循环2修改bool数组，i的倍数都不是素数。
  循环1`(2;i*i<n;i++)`，循环2`(i*i;j<n;j+=i)`

---

+ ✔[3]无重复字符的最长子串：**积分法+hash回溯法**。解法是用个map保存字符与出现的位置，当有重复的时候，回去看哪个位置出现过，那就在那个位置里重新开始遍历。

+ ✔[6]Z 字形变换：可以通过遍历字符串的时间，记录每一行的的字符的下标

+ ✔[8]字符串转换整数 (atoi)：处理过程是有限状态，每个状态的处理也是有限，可以画个表

+ ✔[15]三数之和：**指针夹逼**。求目标值，对数组排序后用夹逼法。由于是三下标，所以必定是两层循环了。中指针遍历，当中指针为某一值时，左右指针夹逼。

+ ✔[31]下一个排列：从右往左找到第一个下跌的数组，在这个数组右边找比这个数组大的最小数，交互这两个数，升序下跌数的右边全部的数

+ ✔[36]有效的数独：**hash回溯法**。遍历时检查现在与以前关系，可以用hash。

+ ✔[55]跳跃游戏：遍历数组，更新能走到的最远的地方，如果遍历时发现所在地方比最远地方更远，则gg，否则就这样一直走能走到最后

+ ✔[62]不同路径：**动态规划，填表法**

+ ✔[92]反转链表 II：**自加节点**。链表处理有时候需要前一个节点，这时候可以在链表前面加一个新的节点，来避免边界问题

+ ✔[98]验证二叉搜索树：二叉搜索树中根遍历是升序数组，判断当前值与前一个值大小关系即可

+ ✔[109]有序链表转换二叉搜索树：**三节点**。中间为root，左边为左子树，右边为右子树。转数组递归，保持链表断开中间递归。

+ ✔[134]加油站：**积分法**

+ ✔[137]只出现一次的数字 II：数量统计可以通过big bit或者`int[]`来统计。位操作，低位逐个操作后再移位会简化实现。

+ ✔[138]复制带随机指针的链表：遍历图依然是深度或者广度，可以用map映射新旧节点

+ ✔[139]单词拆分：使用回溯法的时候注意有没有办法使用一个结果表，像动态规划填表一样

+ ✔[152]乘积最大子数组：**动态规划，积分法**。积分法里边遍历数组边计算，对应动态规划的填表。
  又由于积分法只需有限的前状态，所以积分法应该都可以转换为**临时变量的动态规划**。积分法应该是动态规划的一种子形式。

+ ✔[162]寻找峰值：**二分法**。一开始没注意到，其实是旋转数组的变形。

+ ✔[187]重复的DNA序列：**hash回查**

+ ✔[207]课程表：本质是判断有向图是否有环。
  1. 统计每个节点的入度(`int[]`)和保存每个节点的出节点(`List[]`)
  2. 将入度为0的节点标记已读(如把入度改为-1)，然后将入度为0的出节点的入度减一
  3. 再次查找入度为0节点，重复步骤2。如果没有入度为0的节点了，但还没已读完全部节点，则有环

+ ✔[209]长度最小的子数组：**积分法**

+ ✔[221]最大正方形：**填表法**。某个位置作为正方形的右下角，那么这个正方形大小为左、上和左上格子中min+1。

+ ❓[222]完全二叉树的节点个数：除了最后一层是满树，直接计算。最后一层从左到右小标i，查找第i个叶子节点是否存在。

+ ✔[223]矩形面积：投影到xy轴上

+ ✔[229]求众数 II：**摩尔投票法**。但由于摩尔投票法只是数量最多，不一定能过三分之一。
  所以摩尔投票法之后还要遍历一遍数组统计是不是超过三分之一。

+ ✔[238]除自身以外数组的乘积：这题又是妙呀妙呀。两个新数字，分别表示从左往右和从右往左的累乘，那么下标i即为i的左边累乘乘以右边的累乘。

+ ✔[240]搜索二维矩阵 II：这题又是妙呀妙呀。**排序矩阵搜索**。我以为我好不容易想出了的矩阵范围缩减策略能过，结果还是超时。

---

+ ✔[4]寻找两个正序数组的中位数：第一题就巨难，有一些技巧点
  - 中位数的中间左右两个数，奇偶通用：`(len+1)/2、(len+2)/2`
  1. 创建一个新数组归并，得到中位数，其实归并到一半即可
  2. 使用下标模拟归并过程，同样模拟到一半即可，变为求第k小的数
  3. 下标模拟归并是一个数一个数来的，使用二分法，比较两数组的k/2大小，小的其前必然不是中位数，递归

+ ✔[10]正则表达式匹配：好难好难
  - 动态规划是填表格，虽然不一定能降低时间复杂度，但是能减低实现的难度
  - 在动态规划里有两个数组或者链表（两个n），起码对应的填表是二维数组
  - 一般会初始化二维数组的左上边
  - 对于`i,j`位置，简单的可能会考虑`i-1,j`、`i,j-1`、`i-1,j-1`和两个数组的i和j的条件，得到`i,j`位置结果

+ ✔[25]K 个一组翻转链表：妙呀，妙呀。**链表翻转**
  - 翻转链表不能用数组那种下标对称交换的思路，应该是从左往右把next的方向翻转

+ ✔[32]最长有效括号：难到不是人，不知道怎么总结

+ ✔[37]解数独：**回溯算法**。用回溯其实不难。。。

+ ✔[41]缺失的第一个正数：**原地hash**。通过原地hash排序，再遍历一次。